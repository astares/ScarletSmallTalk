TestCase subclass: #StCompilerTest	instanceVariableNames: 'testClass'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-JS-Test'!!StCompilerTest commentStamp: 'mir 6/11/2018 16:53' prior: 0!!!StCompilerTest methodsFor: 'running' stamp: 'mir 5/29/2018 16:16'!benchmark: iterations	"(500000 // time to run) = approx bytecodes per second"	"5000000 // (Time millisecondsToRun: [10 benchmark]) * 1000"	"3059000 on a Mac 8100/100"    | size flags prime k count |    size := 8190.    iterations timesRepeat:        [        count := 0.        flags := (Array new: size) atAllPut: true.        1 to: size do:            [:i | (flags at: i) ifTrue:                [prime := i+1.                k := i + prime.                [k <= size] whileTrue:                    [flags at: k put: false.                    k := k + prime].                count := count + 1].			i]].    ^ count! !!StCompilerTest methodsFor: 'running' stamp: 'mir 8/20/2018 21:28'!setUp	super setUp.	StCompilerTestClass initialize.	self assert: StCompilerTestClass classInstVar1 = 'classInstVar1'.	self assert: StCompilerTestClass classVar1 = 'classVar1'.	testClass := StCompilerTestClass new.	self assert: testClass notNil! !!StCompilerTest methodsFor: 'running' stamp: 'mir 8/20/2018 21:30'!tearDown	super tearDown.	StCompilerTestClass tearDown! !!StCompilerTest methodsFor: 'running' stamp: 'mir 5/30/2018 11:50'!testBenchmark	self benchmark: 100! !!StCompilerTest methodsFor: 'tests loops' stamp: 'mir 5/29/2018 12:06'!testReturnWhileFalse	testClass value1: 1.	testClass value2: 2.	self assert: testClass returnWhileFalse = 'one'.	testClass value1: 2.	testClass value2: 1.	self assert: testClass returnWhileFalse = testClass! !!StCompilerTest methodsFor: 'tests loops' stamp: 'mir 5/29/2018 12:44'!testReturnWhileTrue	testClass value1: 1.	testClass value2: 2.	self assert: testClass returnWhileTrue = 'one'.	testClass value1: 2.	testClass value2: 1.	self assert: testClass returnWhileTrue = testClass! !!StCompilerTest methodsFor: 'tests loops' stamp: 'mir 5/29/2018 13:42'!testWhileFalseDo	testClass value1: 1.	testClass value2: 3.	self assert: testClass whileFalseDo = 4.	testClass value1: 2.	testClass value2: 1.	self assert: testClass whileFalseDo = 2! !!StCompilerTest methodsFor: 'tests loops' stamp: 'mir 5/29/2018 12:45'!testWhileFalseReturn	self assert: testClass whileFalseReturn = nil! !!StCompilerTest methodsFor: 'tests loops' stamp: 'mir 5/29/2018 13:43'!testWhileTrueDo	testClass value1: 1.	testClass value2: 3.	self assert: testClass whileTrueDo = 3.	testClass value1: 2.	testClass value2: 1.	self assert: testClass whileTrueDo = 2! !!StCompilerTest methodsFor: 'tests loops' stamp: 'mir 5/29/2018 12:45'!testWhileTrueReturn	self assert: testClass whileTrueReturn = nil! !!StCompilerTest methodsFor: 'tests block returns' stamp: 'mir 4/9/2018 22:55'!testBlockExpressionVariableReturnEval	self assert: testClass blockExpressionVariableReturnEval = 16! !!StCompilerTest methodsFor: 'tests block returns' stamp: 'mir 5/3/2019 17:16'!testBlockReturnLiteralReturn	self assert: (testClass blockReturnLiteralReturn isKindOf: BlockClosure).	"exception is thrown in Smalltalk, but not Javascript""	self should: [testClass blockReturnLiteralReturn value = 42] raise: Error"! !!StCompilerTest methodsFor: 'tests block returns' stamp: 'mir 5/3/2019 11:58'!testBlockReturnLiteralValueReturn	self assert: testClass blockReturnLiteralValueReturn = 42! !!StCompilerTest methodsFor: 'tests block returns' stamp: 'mir 4/9/2018 22:51'!testBlockVariableReturnEval	self assert: testClass blockVariableReturnEval = 1! !!StCompilerTest methodsFor: 'tests blocks' stamp: 'mir 4/9/2018 22:54'!testBlockExpressionEval	self assert: testClass blockExpressionEval = 4! !!StCompilerTest methodsFor: 'tests blocks' stamp: 'mir 4/9/2018 22:54'!testBlockExpressionVariableEval	self assert: testClass blockExpressionVariableEval = 9! !!StCompilerTest methodsFor: 'tests blocks' stamp: 'mir 5/12/2018 20:21'!testBlockLiteralEvalReturn	self assert: testClass blockLiteralEvalReturn = 5! !!StCompilerTest methodsFor: 'tests blocks' stamp: 'mir 5/30/2018 16:35'!testBlockReturnTemp	testClass value1: 'one'.	self assert: testClass blockReturnTemp = 'one'! !!StCompilerTest methodsFor: 'tests blocks' stamp: 'mir 5/31/2018 08:59'!testBlockReturnTempBlock	testClass value1: 'one'.	self assert: testClass blockReturnTempBlock value = 'one'! !!StCompilerTest methodsFor: 'tests blocks' stamp: 'mir 4/25/2018 17:23'!testBlockReturnTempEval	testClass value1: 'one'.	self assert: testClass blockReturnTempEval = 'one'! !!StCompilerTest methodsFor: 'tests blocks' stamp: 'mir 4/25/2018 17:26'!testBlockReturnVariableTemp	testClass value1: 'one'.	self assert: testClass blockReturnVariableTemp = 'one'! !!StCompilerTest methodsFor: 'tests blocks' stamp: 'mir 4/9/2018 22:51'!testBlockVariableEval	self assert: testClass blockVariableEval = 2! !!StCompilerTest methodsFor: 'parsing' stamp: 'mir 6/12/2018 14:16'!testParseDigits	| scanner numberString |	scanner := StScanner new.	numberString := scanner scanDigitString: '0.0' readStream.	self assert: numberString = '0'.	numberString := scanner scanDigitString: '0.0.' readStream.	self assert: numberString = '0'.	numberString := scanner scanDigitString: '10r24' readStream.	self assert: numberString = '10'.	numberString := scanner scanDigitString: '0.0.0.0' readStream.	self assert: numberString = '0'.	numberString := scanner scanDigitString: '300.045abs' readStream.	self assert: numberString = '300'.	numberString := scanner scanDigitString: '300.045rounded' readStream.	self assert: numberString = '300'! !!StCompilerTest methodsFor: 'parsing' stamp: 'mir 6/12/2018 14:40'!testParseFloat	| scanner numberString |	scanner := StScanner new.	numberString := scanner scanNumberString: '0.0' readStream.	self assert: numberString = '0.0'.	numberString := scanner scanNumberString: '0.0.' readStream.	self assert: numberString = '0.0'.	numberString := scanner scanNumberString: '300.045abs' readStream.	self assert: numberString = '300.045'.	numberString := scanner scanNumberString: '300.045rounded' readStream.	self assert: numberString = '300.045'! !!StCompilerTest methodsFor: 'parsing' stamp: 'mir 6/12/2018 12:51'!testParseHex! !!StCompilerTest methodsFor: 'parsing' stamp: 'mir 6/12/2018 14:40'!testParseInteger	| scanner numberString |	scanner := StScanner new.	numberString := scanner scanNumberString: '0.0' readStream.	self assert: numberString = '0.0'.	numberString := scanner scanNumberString: '123' readStream.	self assert: numberString = '123'.	numberString := scanner scanNumberString: '123.' readStream.	self assert: numberString = '123'.	numberString := scanner scanNumberString: '300abs' readStream.	self assert: numberString = '300'.	numberString := scanner scanNumberString: '300.rounded' readStream.	self assert: numberString = '300'! !!StCompilerTest methodsFor: 'parsing' stamp: 'mir 6/12/2018 14:41'!testParseRadix	| scanner numberString |	scanner := StScanner new.	numberString := scanner scanNumberString: '10r123' readStream.	self assert: numberString = '10r123'.	numberString := scanner scanNumberString: '10r123rounded' readStream.	self assert: numberString = '10r123'.	numberString := scanner scanNumberString: '10r123abc' readStream.	self assert: numberString = '10r123'! !!StCompilerTest methodsFor: 'tests vars' stamp: 'mir 5/31/2018 18:01'!testClassInstVarAssignment	self assert: testClass class classInstVarReturn = 'classInstVar1'.	testClass class classInstVarAssignment.	self assert: testClass class classInstVarReturn = 'classVar1'! !!StCompilerTest methodsFor: 'tests vars' stamp: 'mir 5/31/2018 18:02'!testClassInstVarReturn	self assert: testClass class classInstVarReturn = 'classInstVar1'! !!StCompilerTest methodsFor: 'tests vars' stamp: 'mir 5/31/2018 17:56'!testClassVarAssignment	self assert: testClass classVarReturn = 'classVar1'.	testClass value1: 'one'.	testClass classVarAssignment.	self assert: testClass classVarReturn = 'one'! !!StCompilerTest methodsFor: 'tests vars' stamp: 'mir 5/31/2018 17:55'!testClassVarReturn	self assert: testClass classVarReturn = 'classVar1'! !!StCompilerTest methodsFor: 'tests vars' stamp: 'mir 4/9/2018 20:16'!testInstVarReturn	self assert: testClass instVarReturn = 'instVar1'! !!StCompilerTest methodsFor: 'tests vars' stamp: 'mir 4/7/2018 14:59'!testVariableAssign	self assert: testClass variableAssign == testClass! !!StCompilerTest methodsFor: 'tests vars' stamp: 'mir 4/7/2018 14:58'!testVariableAssignReturn	self assert: testClass variableReturnAssign = 1! !!StCompilerTest methodsFor: 'tests vars' stamp: 'mir 4/9/2018 18:12'!testVariableReturn	self assert: testClass variableReturn isNil! !!StCompilerTest methodsFor: 'tests vars' stamp: 'mir 4/7/2018 14:59'!testVariableReturnAssign	self assert: testClass variableReturnAssign = 1! !!StCompilerTest methodsFor: 'tests vars' stamp: 'mir 4/7/2018 14:59'!testVariablesAssignReturn	self assert: testClass variablesAssignReturn = 2! !!StCompilerTest methodsFor: 'tests vars' stamp: 'mir 4/7/2018 14:59'!testVariablesReturn	self assert: testClass variablesReturn isNil! !!StCompilerTest methodsFor: 'tests inlining' stamp: 'mir 5/6/2019 09:26'!disabletestIfUndefinedReturn	"we have no way currently to set a Smalltalk inst var to Javascript undefined directly"	"disable for now	self assert: testClass ifUndefinedReturn = 'one'.	testClass value1: 'value42'.	self assert: testClass ifUndefinedReturn = 'one'.	testClass value1: '@value2'.	self assert: testClass ifUndefinedReturn = 'one'.	testClass value2: 2.	self assert: testClass ifUndefinedReturn = 2	"! !!StCompilerTest methodsFor: 'tests inlining' stamp: 'mir 8/20/2018 14:42'!testIfFalseBlockIfTrueReturn	testClass value1: 2.	testClass value2: 1.	self assert: testClass ifFalseBlockIfTrueReturn = #() description: testClass ifFalseBlockIfTrueReturn asString.	testClass value1: 1.	testClass value2: 2.	self assert: testClass ifFalseBlockIfTrueReturn = testClass description: testClass ifFalseBlockIfTrueReturn asString! !!StCompilerTest methodsFor: 'tests inlining' stamp: 'mir 5/1/2018 14:46'!testIfFalseReturn	testClass value1: 1.	testClass value2: 2.	self assert: testClass ifFalseReturn == testClass.	testClass value1: 2.	testClass value2: 1.	self assert: testClass ifFalseReturn = 'one'! !!StCompilerTest methodsFor: 'tests inlining' stamp: 'mir 5/28/2018 15:44'!testIfNilReturn	testClass value1: nil.	self assert: testClass ifNilReturn = 'one'.	testClass value1: 2.	self assert: testClass ifNilReturn = testClass! !!StCompilerTest methodsFor: 'tests inlining' stamp: 'mir 5/28/2018 18:05'!testIfNotNilReturn	testClass value1: nil.	self assert: testClass ifNotNilReturn = testClass.	testClass value1: 2.	self assert: testClass ifNotNilReturn = 'one'! !!StCompilerTest methodsFor: 'tests inlining' stamp: 'mir 4/24/2018 17:07'!testIfTrueIfFalseReturn	testClass value1: 1.	testClass value2: 2.	self assert: testClass ifTrueIfFalseReturn = testClass.	testClass value1: 2.	testClass value2: 1.	self assert: testClass ifTrueIfFalseReturn = 'two'! !!StCompilerTest methodsFor: 'tests inlining' stamp: 'mir 5/1/2018 14:46'!testIfTrueReturn	testClass value1: 1.	testClass value2: 2.	self assert: testClass ifTrueReturn = 'one'.	testClass value1: 2.	testClass value2: 1.	self assert: testClass ifTrueReturn == testClass! !!StCompilerTest methodsFor: 'tests inlining' stamp: 'mir 4/24/2018 17:08'!testIfTrueReturnIfFalse	testClass value1: 1.	testClass value2: 2.	self assert: testClass ifTrueReturnIfFalse = 'one'.	testClass value1: 2.	testClass value2: 1.	self assert: testClass ifTrueReturnIfFalse = testClass! !!StCompilerTest methodsFor: 'tests inlining' stamp: 'mir 5/15/2018 12:43'!testInlineIfTrueIfFalse	testClass value1: 1.	testClass value2: 2.	self assert: testClass inlineIfTrueIfFalse = 'instVar1'.	testClass value1: 2.	testClass value2: 1.	self assert: testClass inlineIfTrueIfFalse = 'instVar2'! !!StCompilerTest methodsFor: 'tests inlining' stamp: 'mir 5/23/2018 19:09'!testInlineReceiverIfTrueIfFalse	testClass value1: 1.	testClass value2: 2.	self assert: testClass inlineReceiverIfTrueIfFalse = 'instVar1'.	testClass value1: 2.	testClass value2: 1.	self assert: testClass inlineReceiverIfTrueIfFalse = 'instVar2'! !!StCompilerTest methodsFor: 'tests inlining' stamp: 'mir 5/23/2018 19:09'!testInlineReturnIfTrueIfFalse	testClass value1: 1.	testClass value2: 2.	self assert: testClass inlineReturnIfTrueIfFalse = 'instVar1'.	testClass value1: 2.	testClass value2: 1.	self assert: testClass inlineReturnIfTrueIfFalse = 'instVar2'! !!StCompilerTest methodsFor: 'tests inlining' stamp: 'mir 5/30/2018 14:29'!testIsKindOfReturn	testClass value1: 2.	self assert: testClass isKindOfReturn not.	testClass value1: 'two'.	self assert: testClass isKindOfReturn! !!StCompilerTest methodsFor: 'tests inlining' stamp: 'mir 5/25/2018 19:25'!testNonLocalReturnIfTrue	testClass value1: 1.	testClass value2: 2.	self assert: testClass nonLocalReturnIfTrue = 'one'.	testClass value1: 2.	testClass value2: 1.	self assert: testClass nonLocalReturnIfTrue = testClass! !!StCompilerTest methodsFor: 'tests inlining' stamp: 'mir 4/24/2018 17:06'!testReturnIfFalse	testClass value1: 1.	testClass value2: 2.	self assert: testClass returnIfFalse = nil.	testClass value1: 2.	testClass value2: 1.	self assert: testClass returnIfFalse = 'one'! !!StCompilerTest methodsFor: 'tests inlining' stamp: 'mir 4/24/2018 17:01'!testReturnIfFalseIfTrue	testClass value1: 1.	testClass value2: 2.	self assert: testClass returnIfFalseIfTrue = 'one'.	testClass value1: 2.	testClass value2: 1.	self assert: testClass returnIfFalseIfTrue = 'two'! !!StCompilerTest methodsFor: 'tests inlining' stamp: 'mir 5/28/2018 15:41'!testReturnIfNil	testClass value1: nil.	self assert: testClass returnIfNil = 'one'.	testClass value1: 2.	self assert: testClass returnIfNil = 2! !!StCompilerTest methodsFor: 'tests inlining' stamp: 'mir 5/30/2018 16:00'!testReturnIfNilIfNotNil	self assert: testClass ifNilIfNotNilReturn = 'one' description: 'should be nil'.	testClass value1: 2.	self assert: testClass ifNilIfNotNilReturn = 'two' description:  'should be not nil:' , testClass ifNilIfNotNilReturn! !!StCompilerTest methodsFor: 'tests inlining' stamp: 'mir 5/31/2018 08:44'!testReturnIfNotNil	self assert: testClass returnIfNotNil = nil.	testClass value1: nil.	self assert: testClass returnIfNotNil isNil.	testClass value1: 2.	self assert: testClass returnIfNotNil = 'one'! !!StCompilerTest methodsFor: 'tests inlining' stamp: 'mir 5/30/2018 14:16'!testReturnIfNotNilIfNil	self assert: testClass ifNotNilIfNilReturn = 'two'.	testClass value1: 2.	self assert: testClass ifNotNilIfNilReturn = 'one'! !!StCompilerTest methodsFor: 'tests inlining' stamp: 'mir 4/24/2018 17:03'!testReturnIfTrue	testClass value1: 1.	testClass value2: 2.	self assert: testClass returnIfTrue = 'one'.	testClass value1: 2.	testClass value2: 1.	self assert: testClass returnIfTrue = nil! !!StCompilerTest methodsFor: 'tests inlining' stamp: 'mir 4/24/2018 17:04'!testReturnIfTrueIfFalse	testClass value1: 1.	testClass value2: 2.	self assert: testClass returnIfTrueIfFalse = 'one'.	testClass value1: 2.	testClass value2: 1.	self assert: testClass returnIfTrueIfFalse = 'two'! !!StCompilerTest methodsFor: 'tests' stamp: 'mir 5/24/2018 19:12'!testAsJavascript	| stString jsString |	stString := ' .0123456789:ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz'.	jsString := stString asJavascript.	stString := '"' , stString , '"'.	self assert: jsString size = stString size description: jsString.	self assert: jsString unescaped = stString description: jsString unescaped.	" '*+-/@' is not escaped in javascript, but not included in the escape test regex.	Consistency is a wonderful thing"	stString := '%21%22%23%24%25%26%27%28%29%2C%3B%3C%3D%3E%3F%5B%5C%5D%5E%60%7B%7C%7D' unescaped.	jsString := stString asJavascript.	self assert: jsString size = (stString size * 3 + 12) description: stString , jsString! !!StCompilerTest methodsFor: 'tests' stamp: 'mir 5/30/2018 12:51'!testBasicAtIfAbsentReturn	testClass value1: 'one'.	self assert: testClass basicAtIfAbsentReturn = 'one'! !!StCompilerTest methodsFor: 'tests' stamp: 'mir 5/30/2018 13:49'!testBasicAtPut	self assert: testClass value2 isNil.	testClass value1: 5.	testClass basicAtPut.	self assert: testClass value2 = 5! !!StCompilerTest methodsFor: 'tests' stamp: 'mir 5/30/2018 08:51'!testBasicAtReturn	self assert: testClass basicAtReturn isNil.	testClass value2: 5.	self assert: testClass basicAtReturn = 5! !!StCompilerTest methodsFor: 'tests' stamp: 'mir 5/30/2018 12:53'!testBasicAtVariableIfAbsentReturn	self assert: testClass basicAtVariableIfAbsentReturn = 'one'.	testClass value1: '@value2'.	testClass value2: 5.	self assert: testClass basicAtVariableIfAbsentReturn = 5! !!StCompilerTest methodsFor: 'tests' stamp: 'mir 5/30/2018 08:51'!testBasicAtVariableReturn	testClass value1: '@value2'.	testClass value2: 5.	self assert: testClass basicAtVariableReturn = 5.	testClass value1: '@value42'.	self assert: testClass basicAtVariableReturn isNil! !!StCompilerTest methodsFor: 'tests' stamp: 'mir 4/9/2018 20:33'!testBinaryBinaryReturn	self assert: testClass binaryBinaryReturn = 0! !!StCompilerTest methodsFor: 'tests' stamp: 'mir 4/9/2018 20:33'!testBinaryBracedReturn	self assert: testClass binaryBracedReturn = 7! !!StCompilerTest methodsFor: 'tests' stamp: 'mir 4/9/2018 20:33'!testBinaryReturn	self assert: testClass binaryReturn = 3! !!StCompilerTest methodsFor: 'tests' stamp: 'mir 5/24/2018 12:08'!testBindSmalltalkClassName	| result |	result := testClass bindSmalltalkClassName asString.	self assert: result = 'StCompilerTestClass' description: result! !!StCompilerTest methodsFor: 'tests' stamp: 'mir 4/26/2018 11:06'!testCascadeKeywordReturn	| collection |	collection := OrderedCollection new.	testClass value1: collection.	self assert: testClass cascadeKeywordReturn = 2.	self assert: (collection at: 1) = 1.	self assert: (collection at: 2) = 2! !!StCompilerTest methodsFor: 'tests' stamp: 'mir 4/26/2018 11:04'!testCascadeKeywordReturnYourself	| collection result |	collection := OrderedCollection new.	testClass value1: collection.	result := testClass cascadeKeywordReturnYourself.	self assert: result == collection.	self assert: (result at: 1) = 1.	self assert: (result at: 2) = 2! !!StCompilerTest methodsFor: 'tests' stamp: 'mir 4/26/2018 11:05'!testCascadeLiteralReturn	self assert: testClass cascadeLiteralReturn not! !!StCompilerTest methodsFor: 'tests' stamp: 'mir 4/26/2018 11:02'!testCascadeUnaryReturn	testClass value1: 3.	self assert: testClass cascadeUnaryReturn = 3.	testClass value1: 'one'.	self assert: testClass cascadeUnaryReturn = 'one'! !!StCompilerTest methodsFor: 'tests' stamp: 'mir 4/7/2018 14:56'!testEmptyMethod	self assert: testClass notNil.	self assert: testClass emptyMethod == testClass! !!StCompilerTest methodsFor: 'tests' stamp: 'mir 4/9/2018 20:57'!testKeywordReturn	self assert: (testClass keywordMethodReturn: 1) = 1! !!StCompilerTest methodsFor: 'tests' stamp: 'mir 4/9/2018 20:58'!testKeywordReturnWith	self assert: (testClass keywordMethodReturn: 1 with: 2) = 2! !!StCompilerTest methodsFor: 'tests' stamp: 'mir 4/9/2018 20:58'!testKeywordReturnWithWith	self assert: (testClass keywordMethodReturn: 1 with: 2 with: 3) = 3! !!StCompilerTest methodsFor: 'tests' stamp: 'mir 8/14/2018 11:17'!testLiteralArrayWithBoolean	| array |	array := testClass literalArrayWithBoolean.	self assert: array size = 3.	self assert: (array at: 1).	self deny: (array at: 2).	self assert: (array at: 3).! !!StCompilerTest methodsFor: 'tests' stamp: 'mir 4/7/2018 14:58'!testLiteralArrayWithCharacters	| array |	array := testClass literalArrayWithCharacters.	self assert: array size = 3.	self assert: (array at: 1) = $a.	self assert: (array at: 2) = $b.	self assert: (array at: 3) = $c.! !!StCompilerTest methodsFor: 'tests' stamp: 'mir 8/14/2018 11:03'!testLiteralArrayWithNil	| array |	array := testClass literalArrayWithNil.	self assert: array size = 3.	self assert: (array at: 1) isNil.	self assert: (array at: 2) isNil.	self assert: (array at: 3) isNil.! !!StCompilerTest methodsFor: 'tests' stamp: 'mir 4/25/2018 16:37'!testLiteralArrayWithNumbers	| array |	array := testClass literalArrayWithNumbers.	self assert: array size = 5.	self assert: (array at: 1) = 42.	self assert: (array at: 2) = -42.	self assert: (array at: 3) = 123.45.	"disabled self assert: (array at: 4) = 123.45." "1.2345e2"	self assert: (array at: 4) = 146. "2r10010010"	self assert: (array at: 5) = 40960. "16rA000"	! !!StCompilerTest methodsFor: 'tests' stamp: 'mir 4/7/2018 14:58'!testLiteralArrayWithStrings	| array |	array := testClass literalArrayWithStrings.	self assert: array size = 3.	self assert: (array at: 1) = '1'.	self assert: (array at: 2) = '2'.	self assert: (array at: 3) = '3'.! !!StCompilerTest methodsFor: 'tests' stamp: 'mir 5/24/2018 18:40'!testLiteralCRString	| string |	string := testClass literalCRString.	self assert: string size = 11 description: string.	self assert: string = 'hello%0Dworld' unescaped description: string! !!StCompilerTest methodsFor: 'tests' stamp: 'mir 4/7/2018 14:58'!testLiteralCharacter	| char |	char := testClass literalCharacter.	self assert: char asciiValue = 97! !!StCompilerTest methodsFor: 'tests' stamp: 'mir 5/25/2018 16:25'!testLiteralFalse	self assert: testClass literalFalse not! !!StCompilerTest methodsFor: 'tests' stamp: 'mir 5/25/2018 16:26'!testLiteralSelf	self assert: testClass literalSelf == testClass! !!StCompilerTest methodsFor: 'tests' stamp: 'mir 5/24/2018 12:29'!testLiteralString	| string |	string := testClass literalString.	self assert: string size = 11 description: string.	self assert: string = 'hello world' description: string! !!StCompilerTest methodsFor: 'tests' stamp: 'mir 5/14/2018 13:13'!testLiteralSymbol	self assert: testClass literalSymbol == #symbolic! !!StCompilerTest methodsFor: 'tests' stamp: 'mir 5/25/2018 16:25'!testLiteralTrue	self assert: testClass literalTrue! !!StCompilerTest methodsFor: 'tests' stamp: 'mir 4/9/2018 20:22'!testUnaryReturn	self assert: testClass unaryReturn = 3! !!StCompilerTest methodsFor: 'tests' stamp: 'mir 4/9/2018 20:22'!testUnaryUnaryReturn	self assert: testClass unaryUnaryReturn not! !